> 1) {
		if(overlay == ""){
			twc.height = twc.height / ratio*10;
			twc.width = twc.width / ratio*10;
			ve.height = ve.height / ratio*10;
			ve.width = ve.width / ratio*10;		
		}else{
			twc.height = twc.height / ratio;
			twc.width = twc.width / ratio;
			ve.height = ve.height / ratio;
			ve.width = ve.width / ratio;
			}
		}
		interfaceElement.appendChild(this.getIcon(icons['ve'].name, height - (ve.height + wxtools.MapPane_frameBuffer), wxtools.MapPane_frameBuffer, ve.width, ve.height));
		interfaceElement.appendChild(this.getIcon(icons['twc'].name, height - (twc.height + wxtools.MapPane_frameBuffer), width - (twc.width + wxtools.MapPane_frameBuffer), twc.width, twc.height));
		
		return interfaceElement;
	},
	
	// generate the innerHTML text for a new set of positioned image tiles wrapped in a parent container
	getTilesSource:function(id, center, width, height, level, tileSet, overlay, transparency) {
		if (wxtools.MapPane_debug) wxtools.log('MapPane.getTilesSource(' + center + ',' + width + ',' + height + ',' + level + ',' + tileSet + ',' + overlay + ',' + transparency + ')');
		
		var projection = this.getProjection(level);
		var centerXY = projection.project(center);
		
		var minTile = this.getMinTile(centerXY, width, height, level, projection);
		var maxTile = this.getMaxTile(centerXY, width, height, level, projection);
		
		var tiles = ['<div